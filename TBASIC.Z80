;
;==============================================================================
; TANDY (RADIO SHACK) MODEL 1 LEVEL 2 BASIC FOR CPM
; Version 1.0 Feb 2025
;==============================================================================
; Author: Mark Pruden
;------------------------------------------------------------------------------
; Change Log:
;   2025-02-11 [MAP] Initial release of version 1.0
;===============================================================================
;
; INFORMATION
;   * SYSTEM command now perform exit from basic.
;   * Video Driver replaced, supports ANSI escapes for most control characters
;   * keyboard Driver replaced implmentng ANSI arrow keys
;   * Hi memory check is established from CP/M, not physical ram size
; KEYBOARD
;   * BREAK - <CTRL-A> - Mapped to ?
;   * CLEAR - Mapped to ?
; LANGUAGE
;   * SYSTEM command (monitor) replacd - now perform exit from basic
;   * Cassette All commands removed CLOAD, CSAVE or disabled PRINT#, INPUT#
;   * Graphics All commands removed SET, RESET, POINT,
; TECHNICAL
;   * Removed all support for Cassette
;   * Removed support for 32 Character Mode
;   * Removed Disk Boot startup from ROM
;   * Removed ALL HW dependancies
;   * RAM (communications area) is fully supported, but starts at $3000, not $4000.
;   * ROM subroutine addresses no longer valid, but will work (different addresses)
;   * RST commands not supported, must be replaced wiht CALL's
; TODO
;   * PRINT@[0-1023] command, uses HW address, needs fixing
;   * Disk Routines need writing SAVE LOAD, then others
;   * Line Printer Driver need implemting
; ISSUES
;   * Graphics charater not nativly supported, requires terminal font to be installed
;     this may or may not work.
;   * Video ram does not exist POKES to video ram will cause failures
;   * INSTR$ will not detect a contious key press, (i.e. no held keys)
;     it will respond to Key repeat (multiple presses) if supported in HW
;
;===============================================================================
;
restart		.equ	$0000		; CP/M restart vector
bdos		.equ	$0005		; BDOS invocation vector
sysfcb1		.equ	$005C		; System FCB 1
comtail		.equ	$0080		; 128byte buffer
;
bd_open		.equ	15		; open file
bd_read		.equ	20		; read sequential
;
ESC		.equ	$1B
;
;===============================================================================
; Main Program
;===============================================================================
;
	.org	$0100			; standard CP/M TPA executable
;
	ld	(stksav),sp		; save old stack value
	xor	a			; clear accumulator (for INIT)
	jp	INIT			; run the Rom from INIT
cleanup:
	ld	sp,(stksav)		; restore stack from saved stack
	jp	restart			; return to CP/M via restart
;
;===============================================================================
; TANDY EMBEDDED ROUTINES
;   (these are new embedded routines)
;===============================================================================
;
MEMORY:
	; determinate and return upper RAM address in HL
	; called during startup instead of ROM detecting RAM manually.
	;
	ld	hl,(bdos+1)		; load from BDOS address
	dec	h			; previous page
	ld	l,$E0			; end of Page, less 32 bytes (buffer?)
	; Because the BDOS, like the BIOS, starts on a page boundary, the most
        ; significant byte of the address of the BDOS entry tells you in which page the
        ; BDOS starts. You must subtract 1 from the value in TOPRAM to get the highest
        ; page number that you can use in your program. Note that when you use this
        ; technique, you assume that the CCP will be overwritten since it resides in memory
        ; just below the BOOS.
	ret
;
INIT3:
	; called after full initialisation, but before READY prompt
	; allows additional setup tasks to be performed
	; todo setup disk basic Vector's - e.g.load and save
	ld	a,OPJPNN		; opcode for JP nnnn
	;
	ld	hl,DLOAD		; address of our Disk LOAD function
	ld	(DVLOAD),a		; set the JP Instruction into Vector Table
	ld	(DVLOAD+1),hl		; set the vector to function
	;
	ld	hl,DSAVE		; address of our Disk SAVE function
	ld	(DVSAVE),a		; set the JP Instruction into Vector Table
	ld	(DVSAVE+1),hl		; set the vector to function
	;
	ret
;
DSPCUR:
	; part of Display Routines - to signal cursor movement
	; called DE=screen location (0-1023) to move cursor to

	ld	(CURSOR),de	; update the cursor address from DE
	; todo send characters to display to do the update
	ret
;
;===============================================================================
; TANDY COMMAND REPLACEMENTS
;   (these are command replacements)
;===============================================================================
;
SYSTEM:
	jp 	cleanup		; when the system routine is called EXIT
;
CLOAD:
CSAVE:
SET:
RESET:
POINT:
	jp	L3ERR		;Commands that are ?L3 Error
;
;===============================================================================
; DISK SAVE AND LOAD
;===============================================================================
;
DLOAD:
;	call	FRMEVL		; evaluate the string expression at the location HL
;	call	FRESTR		; check and get string pointer in HL
;	;
;	ld	a,(hl)		; length byte, need to check it
;	or	a
;	jp	z,FCERR		; ensure it isnt 0 length
;;	cp	8
;;	jp	nc,FCERR	; >= 8 so report the erro
;	;
;	inc	hl		; the string pointer
;	ld	e,(hl)		; dereference the string pointer
;	inc	hl
;	ld	d,(hl)
;	ex	de,hl		; move DE (string pointr) into HL
;	; TODO All above code could be removed, HL already contains pointer to String, excepting we may want to skip " ?

	; The HL pointer already comes with pointer to input string.
	ld	de,sysfcb1	; target FCB
	call	convert		; convert filename to FCB
	;
	;ld	de,sysfcb1+1	; target address is FCB NAME field
	;call	MOVREG		; move String from HL (VARPTR) to DE (simple)
	;
	ld	de,sysfcb1
	ld	c,bd_open	; open file
	call	bdos
	;
	inc	a		; ie Z if file not open
	jp	z,FCERR		; file not opened.
	;
	ld	de,sysfcb1	; read first sector
	ld	c,bd_read	; read sequential
	call	bdos
	jp	nz,FCERR	; check read worked
	;
	ld	a,(comtail)	; CPM read buffer address
	cp	$FF		; check first byte is $FF - meaning basic program.
	jp	nz,FCERR	; error if not a $FF basic program
	;
	call	SCRTCH		; basic NEW, initialize system vars
	;
	ld	de,(TXTTAB)	; starting address of PST to load data to
	or	$FF		; signal NZ - first loop for Z test below
DLLOP1:
	; init the transfer 128 bytes loop
	ld	hl,comtail	; source address in CPM buffer
	ld	c,$80		; main loop counter - copy 128 bytes
	jr	z,DLLOP3	; NOT the first timearound, skip
	inc	hl		; first time we skip first byte $FF
	dec	c		; copying 1 less byte
	;
DLLOP3:
	; start of loop - reseting zero counter
	ld	b,3		; looking for 3 zeros for termination
DLLOP4:
	; start of loop
	ld	a,(hl)		; transfer a byte from source
	ld	(de),a		; transfer to the destination
	inc	hl		; inc the memory pointers
	inc	de
	or	a		; was the byte a transferred a ZERO
	jr	nz,DLLOP6	; if received a != 0, continue loop
	dec	b		; the zero counter 3->0
	jr	z,DLLOP9	; received 3 $00 so finish here
	dec	c		; the actual loop counter
	jr	nz,DLLOP4	; main loop not reseting zero counter
	jr	DLLOP7		; finished transfer
DLLOP6:
	dec	c		; the actual loop counter
	jr	nz,DLLOP3	; main loop reseting the zero counter
DLLOP7:
	; read next secor
	push	bc		; save the zero counter
	push	de		; save the target address
	ld	de,sysfcb1	; read first sector
	ld	c,bd_read	; read sequential
	call	bdos
	pop	de
	pop	bc
	;
	jr	z,DLLOP1	; success read, loop round and move data
	dec	a		; fail read adjust error=1 (end of file)
	jp	nz,FCERR	; Not EOF error - some other error hard fail
DLLOP9:
	ld	(VARTAB),de	; After three 000 - Save the new end of the BASIC program pointer.
	;
	ld	de,(TXTTAB)	; pointer to Prog Statement Table
	jp	FINIDE		; Finish Up, same as CLOAD (this code based on)
;
DSAVE:
	ret
;
;                        TXTTAB 32E9 -- VV
; 00 32E0 -- - - - - - - - - - - - - -  F4 32 0A 00 41 24 20   <.5K..2*...2..A$ >
; 00 32F0 -- D5 20 C9 00 05 33 0F 00 8F 20 41 24 D5 22 22 20   <. ...3... A$."" >
; 00 3300 -- 8D 20 31 30 00 18 33 11 00 8F 20 41 24 D5 22 20   <. 10..3... A$." >
; 00 3310 -- 22 20 8D 20 31 30 30 00 38 33 15 00 8F 20 F6 28   <" . 100.83... .(>
; 00 3320 -- 41 24 29 D4 D5 33 32 20 B2 20 41 24 2C 20 3A 95   <A$)..32 . A$, :.>
; 00 3330 -- 20 B2 20 22 20 22 2C 00 44 33 16 00 B2 20 F6 28   < . " ",.D3... .(>
; 00 3340 -- 41 24 29 00 4D 33 32 00 8D 20 31 30 00 59 33 64   <A$).M32.. 10.Y3d>
; 00 3350 -- 00 B2 20 22 42 59 45 22 00 00 00 EB CD FB 35 EB   <.. "BYE"......5.>
;                              VARTAB 335B -- ^^
; 10 A$ = INKEY$
;  15 IF A$="" GOTO 10
;  17 IF A$=" " GOTO 100
;  21 IF ASC(A$)>=32 PRINT A$, ELSE PRINT " ",
;  22 PRINT ASC(A$)
;  50 GOTO 10
;  100 PRINT "BYE"
;
; ---------------------------
; ORIGINALLY FROM SYSCOPY.ASM
; Convert a filename at (HL) into an FCB at (DE).
; Includes wildcard expansion.
; On return, A=0 if unambiguous name specified, and
; (HL) points to character following filename spec
;
convert:
	ex	de,hl		; DE: file name ; HL: target FCB
	ld	a,(de)		; get first character.
	or	a
	jp	z,convrt1
	sbc	a,'A'-1		; might be a drive name, convert to binary.
	ld	b,a		; and save.
	inc	de		; check next character for a ':'.
	ld	a,(de)
	cp	':'
	jp	z,convrt2
	dec	de		; nope, move pointer back to the start of the line.
convrt1:
	ld	a,0		; 0 is default drive, was from BDOS Function 25 (+1)
	ld	(hl),a
	jp	convrt3
convrt2:
	ld	a,b		; assign drive letter specifically
	ld	(hl),b
	inc	de
	; Convert the base file name.
convrt3:ld	b,08h
convrt4:ld	a,(de)
	call	delim
	jp	z,convrt8
	inc	hl
	cp	'*'		; note that an '*' will fill the remaining
	jp	nz,convrt5	; field with '?'
	ld	(hl),'?'
	jp	convrt6
convrt5:ld	(hl),a
	inc	de
convrt6:dec	b
	jp	nz,convrt4
convrt7:ld	a,(de)
	call	delim		; get next delimiter
	jp	z,getext
	inc	de
	jp	convrt7
convrt8:inc	hl		; blank fill the file name
	ld	(hl),' '
	dec	b
	jp	nz,convrt8
getext:	ld	b,03h		; Chars in Extension we need to populate
	cp	'.'
	jp	nz,getex4a	; didnt find a ".", so set to default
	inc	de
getext1:ld	a,(de)
	call	delim
	jp	z,getext5
	inc	hl
	cp	'*'		; ???
	jp	nz,getext2
	ld	(hl),'?'
	jp	getext3
getext2:ld	(hl),a
	inc	de
getext3:dec	b
	jp	nz,getext1	; loop processing the EXT
getext4:ld	a,(de)
	call	delim
	jp	z,getext6	; found a delimiter so finish
	inc	de
	jp	getext4		; loop round until we have delim
getex4a:inc	hl		; Fill in .BAS
	ld	(hl),'B'
	inc	hl
	ld	(hl),'A'
	inc	hl
	ld	(hl),'S'
	jr	getext6		; continue
getext5:inc	hl		; Fill in remainder with blanks
	ld	(hl),' '
	dec	b
	jp	nz,getext5
getext6:ld	b,24
getext7:inc	hl		; Fill 24 bytes after extension with 0
	ld	(hl),0
	dec	b
	jp	nz,getext7
	ret
delim:	or	a		; Check character at (DE) for delimiter.
	ret	z
	cp	' '		; blank
	ret	z
	jr	c,delim1	; handle control characters
	cp	'.'		; FILE.EXT
	ret	z
	cp	':'		; A:
	ret	z
	cp	'"'		; end of string " in basic
	ret	z
	cp	'*'		; wildcard STAR* - first matching ???
	ret
delim1:
	; treat control chars as delimiters
	xor	a		; set Z
	ret			; return
;
;===============================================================================
; TANDY DRIVER ROUTINES
;===============================================================================
;
DSPDRV:
	; This is the video driver. On entry, the character to be displayed should
	; be in the C register. On exit, A would contain the character at the cursor
	; (if called for an INPUT). This routine handles scrolling etc.
        ; Register IX points to the DCB, so IX+0 = the DCB type, IX+1 = LSB of the
        ; Driver Address, IX+2 = MSB of the Driver Address, IX+3 = LSB of the Cursor
        ; Position, IX+4 = MSB of the Cursor Position, IX+5 = Cursor Character,
        ; IX+6 = “D”, and IX+7=”O”
	push	af
	push	hl
	ld	a,c		; char in A
	call	prtspc		; print special char
	jr	z,dspfin	; nothing further to print
	call	prtchr		; print it.
	ld	hl,(CURSOR)	; update cursor
	inc	hl
	ld	(CURSOR),hl
dspfin:	pop	hl		; restore registers
	pop	af
	ret
;
spchrtab:
	; Table is mapping from TRS-80 charater to ANSI terminal codes
	;    TRS-CHR, CTL, Terminal String (5 bytes)
	.db	BACKS,  2, $08, $20, $08,   0, 0
	.db	ENTER,  1, $0D, $0A,   0,   0, 0
	.db	CURON,  0,   0,   0,   0,   0, 0
	.db	CUROFF, 0,   0,   0,   0,   0, 0
	.db	MODE32, 0,   0,   0,   0,   0, 0
	.db	ARLEFT, 2, $1B, '[', '1', 'D', 0
	.db	ARIGHT, 3, $1B, '[', '1', 'C', 0
	.db	ARDOWN, 0, $1B, '[', '1', 'B', 0
	.db	ARUP,   0, $1B, '[', '1', 'A', 0
	.db	CHOME,  1, $1B, '[', 'H',   0, 0
;	.db	CLINE,  1, $1B, '[', '?',   0, 0
	.db	ELINE,  0, $1B, '[', 'K',   0, 0
	.db	CLRKEY, 0, $1B, '[', 'J',   0, 0
	.db	0 ; table terminator
;
; CTL - Defines effective cursor Pos
;   0 = Do Noting
;   1 = Set pos to ZERO
;   2 = Subtract 1 from current pos
;   3 = Add 1 from current pos
;
prtspc:
	ld	b,a
	ld	hl,spchrtab	; start of table
	dec	h		; reversal of next statement
prtspc1:
	inc	h
prtspc2:
	ld	a,(hl)
	cp	0
	jr	z,prtspcfin	; detect end of table
	cp	b
	jr	z,prtspcfound	; found mathch in table
	ld	a,7		; num bytes in each entry
	add	a,l
	ld	l,a		; hl = hl + 7, with carry
	jr	c,prtspc1	; if carry loop and inc H
	jr	prtspc2		; loop without carry
prtspcfin:
	ld	a,b		; restore the original byte
	or	a		; set status - Thus print it.
	ret

prtspcfound:
	inc	hl
	ld	de,(CURSOR)	; ld the cursor
	ld	a,(hl)		; get the control byte
	or	a		; zero test
	jr	z,writechar	; nothing to do
	cp	2		; check
	jr	z,cursorsub	; =2
	jr	nc,cursoradd	; >2
	; fallthrught 		; <2
cursorzero
	ld	de,0
	jr	writechar
cursoradd:
	inc	de
	jr	writechar
cursorsub:
	dec	de
writechar:
	ld	(CURSOR),de	; save the cursor
	inc	hl		; start of string
	call	prtstr		; print it
	xor	a
	ret
;
;===============================================================================
;
KBDDRV:
	; This is the keyboard driver. It scans the keyboard and converts the bit
	; pattern obtained to ASCII and stores it in the A register.
        ; On entry, [IX] should point to the DCB, which is laid out as follows:
        ; On exit, Register A to hold the data byte received (or 0 if none).
	push	bc
	push	hl
	;
	call	getchr
	;
	or	a		; set flags
	jr	z,kbdret	; nothing to process return NOW.
	;
	ld	hl,kbdesc	; address of ESC Flags
	bit	0,(hl)		; test if prior char was an escape
	jr	nz,prioresc	; we got a ESC in previous char
	;
	cp	ESC		; test if this char was an ESC
	jr	z,newesc	; we received an ESC
	;
	jr	kbdret		; return char we received unmodified
newesc:
	set	0,(hl)		; set flag indicating we recied ESC
	jr	kbdretzero	; and respond with 0
prioresc:
	;
	; the following is a hack to discard extra [ char's while in ESC
	cp	ESC+$40		; was it a [ character
	jr	z,kbdretzero	; then discard it
	;
	res	0,(hl)		; clear flag indicating we recieved ESC
	;
	ld	hl,esckeymap	; now replace hl with the lookup table
	ld	b,a		; save char in B
prioresc1:
	ld	a,(hl)		; get the 1st val from lookup table
	inc	hl		; second column, result char
	cp 	0		; end of table marker
	jr	z,kbdretzero	; reached table end, return a ZERO character
	cp	b		; match to our saved kbd char
	jr	z,escmatch	; if matched then process it.
	inc	hl		; next table entry
	jr	prioresc1	; loop
escmatch:
	ld	a,(hl)		; get the NEW ascii char from lookup
	jr	kbdret		; return this new value
kbdretzero:
	xor	a		; clear result
kbdret:
	or	a		; set flags
	pop	hl
	pop	bc
	ret			; and return
;
esckeymap:
	; received eSC chr mapping to TRS ASCII Key
	.db	'A', ARUP
	.db	'B', ARDOWN
	.db	'C', ARIGHT
	.db	'D', ARLEFT
	.db	'F', BREAK	; not working (END)
	.db	'H', CLRKEY	; not working (HOME)
	.db	0
;
; SYSTEM 80
; Up arrow was called ESC,
; down arrow key was CNTL
; Left Arrow key was called BACK SPACE.
; MISTER FPGA
; Clear is simulated by the PC keyboard’s Home key
; Break is the PC keyboard’s Escape key.
;
;===============================================================================
;
PRTDRV:
	; According to the original ROM notes, this is the Printer Driver.
	; On entry, Register C to hold the character to be sent to the printer,
	; and [IX] should point to the DCB,
	call	lstchr		; BDOS call to output to LST device
	ret
;
;===============================================================================
; Utility Routines
;===============================================================================
;
; Print a zero terminated string at (HL) without destroying any registers
;
prtstr:
	push	af
prtstr1:
	ld	a,(hl)		; get next char
	or	a
	jr	z,prtstr2
	call	prtchr
	inc	hl
	jr	prtstr1
prtstr2:
	pop	af
	ret
;
; Print character in A
prtchr:
	push	af
	push	bc		; save registers
	push	de
	push	hl
	ld	e,a		; character to print in E
	ld	c,$02		; BDOS function to output a character
	call	bdos		; do it
	pop	hl		; restore registers
	pop	de
	pop	bc
	pop	af
	ret
;
; Get a character from console, return in A
; returs zero if nothing available
;
getchr:
	push	bc		; save registers
	push	de
	push	hl
	ld	e,$FF		; read a character
	ld	c,$06		; BDOS direct i/o function
	call	bdos		; do it
	pop	hl		; restore registers
	pop	de
	pop	bc
	ret
;
; Print character in A
lstchr:
	push	af
	push	bc		; save registers
	push	de
	push	hl
	ld	e,a		; character to print in E
	ld	c,$05		; BDOS function to output a character
	call	bdos		; do it
	pop	hl		; restore registers
	pop	de
	pop	bc
	pop	af
	ret
;
;===============================================================================
; Constants
;===============================================================================
;
HDGMSG:	.DB	"RADIO SHACK LEVEL II BASIC",ENTER
	.DB	"for CP/M (M.Pruden) Alpha1",ENTER,0
;
;===============================================================================
; Working data
;===============================================================================
;
stksav	.dw	0		; stack pointer saved at start
kbdesc	.db	0		; have we recieved an KBD escape character
;
;FCB:
;fcbDRV:	.db	0		; drive
;fcbFIL:	.db	"        "	; 8 char filename
;fcbTYP	.db	"BAS"		; file type
;fcbEXT	.db	0		;
;fcbRES	.dw	0		; reserved
;fcbREC	.db	0		; record count
;fcbABU	.dw	0,0,0,0		; Image of the second half of the directory entry
;	.dw	0,0,0,0
;fcbCUR	.db	0		; current record
;fcbRRN	.db	0,0,0		; random record number
;
;===============================================================================
; TANDY EMBEDDED BASIC
;===============================================================================
;
RAM:		.equ	$3000	; defines the Start of working RAM, after ROM
#define 	_EMBED		; defines embedded use of the ROM
;
#include 	"MDL1LEV2.Z80"	; INCLUDE the ROM file itself.
;
